# Nerdigy.Mediator LLM Reference

This file is optimized for machine ingestion. It summarizes package boundaries, key contracts, registration patterns, and runtime semantics.

## Package Boundaries

- `Nerdigy.Mediator.Abstractions`
  - Public contracts and delegates only.
  - Use in shared libraries that define requests/notifications/handlers but do not host runtime dispatch.
- `Nerdigy.Mediator`
  - Core runtime dispatch for `Send`, `Publish`, and `CreateStream`.
  - Pipeline execution and exception processing.
- `Nerdigy.Mediator.DependencyInjection`
  - DI registration and assembly scanning.
  - Includes runtime and abstractions transitively.

## Install

```bash
dotnet add package Nerdigy.Mediator.DependencyInjection
```

## DI Registration

```csharp
using Nerdigy.Mediator.DependencyInjection;

services.AddMediator(options =>
{
    options.RegisterServicesFromAssemblyContaining<Program>();
});
```

This registers:
- `IMediator`
- `ISender`
- `IPublisher`
- scanned handlers, pipeline components, and exception components

## Core Dispatch Contracts

```csharp
public interface IMediator : ISender, IPublisher;
```

```csharp
public interface ISender
{
    Task<TResponse> Send<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken = default);
    Task Send(IRequest request, CancellationToken cancellationToken = default);
    IAsyncEnumerable<TResponse> CreateStream<TResponse>(IStreamRequest<TResponse> request, CancellationToken cancellationToken = default);
}
```

```csharp
public interface IPublisher
{
    Task Publish<TNotification>(TNotification notification, CancellationToken cancellationToken = default)
        where TNotification : INotification;
}
```

## Message Contracts

```csharp
public interface IRequest<out TResponse> : IBaseRequest;
public interface IRequest : IRequest<Unit>;
public interface IStreamRequest<out TResponse> : IBaseRequest;
public interface INotification;
```

Rules:
- One request type maps to exactly one request handler.
- One stream request type maps to exactly one stream handler.
- Notifications can have zero to many handlers.

## Handler Contracts

```csharp
public interface IRequestHandler<in TRequest, TResponse>
    where TRequest : IRequest<TResponse>;
```

```csharp
public interface IRequestHandler<in TRequest>
    where TRequest : IRequest;
```

```csharp
public interface IStreamRequestHandler<in TRequest, out TResponse>
    where TRequest : IStreamRequest<TResponse>;
```

```csharp
public interface INotificationHandler<in TNotification>
    where TNotification : INotification;
```

## Pipeline Contracts

```csharp
public interface IRequestPreProcessor<in TRequest> where TRequest : IBaseRequest;
public interface IPipelineBehavior<in TRequest, TResponse> where TRequest : IRequest<TResponse>;
public interface IRequestPostProcessor<in TRequest, in TResponse> where TRequest : IRequest<TResponse>;
public interface IStreamPipelineBehavior<in TRequest, TResponse> where TRequest : IStreamRequest<TResponse>;
```

Execution order for standard requests:
1. `IRequestPreProcessor<TRequest>` in registration order
2. `IPipelineBehavior<TRequest,TResponse>` outer to inner in registration order
3. handler
4. `IRequestPostProcessor<TRequest,TResponse>` in registration order

## Exception Contracts

```csharp
public interface IRequestExceptionHandler<in TRequest, TResponse, in TException>
    where TRequest : IRequest<TResponse>
    where TException : Exception;
```

```csharp
public interface IRequestExceptionAction<in TRequest, in TException>
    where TRequest : IBaseRequest
    where TException : Exception;
```

```csharp
public interface IStreamRequestExceptionHandler<in TRequest, TResponse, in TException>
    where TRequest : IStreamRequest<TResponse>
    where TException : Exception;
```

Semantics:
- Exception handlers run first, from most specific exception type to least specific.
- Calling `state.SetHandled(...)` suppresses rethrow and returns fallback response.
- Exception actions run only when no exception handler marked the exception handled.

## Notification Publisher Strategy

Options:
- `Sequential` (default): await each handler in order.
- `Parallel`: run handlers concurrently using `Task.WhenAll`.

Configure:

```csharp
options.UseNotificationPublisherStrategy(
    NerdigyMediatorNotificationPublisherStrategy.Sequential);
```

or

```csharp
options.UseNotificationPublisherStrategy(
    NerdigyMediatorNotificationPublisherStrategy.Parallel);
```

## High-Signal Prompt Pattern

Use this when asking an LLM to generate code:

```text
Implement this feature using Nerdigy.Mediator on .NET 10.
Use IRequest/IRequestHandler for one-to-one request flows.
Use INotification/INotificationHandler for one-to-many fan-out.
Use IStreamRequest/IStreamRequestHandler for streaming.
Preserve cancellation tokens in all async paths.
Register with services.AddMediator(options => options.RegisterServicesFromAssemblyContaining<...>()).
Output complete compileable files and minimal tests.
```

## Canonical Source Pages

- `/guide/llm-quickstart`
- `/guide/decision-matrix`
- `/guide/recipes`
- `/guide/getting-started`
- `/guide/dependency-injection`
- `/guide/troubleshooting`
- `/api/cheatsheet`
- `/api/contracts`
- `/api/runtime-behavior`
